---
import Layout from "../layouts/Layout.astro";
import ThemeToggle from "../components/ThemeToggle.astro";

const title = "Shopping List";
const baseUrl = import.meta.env.BASE_URL;
---

<Layout title={title}>
  <Fragment slot="theme-toggle">
    <ThemeToggle />
  </Fragment>

  <header class="page-header">
    <div class="header-top">
      <a href={import.meta.env.BASE_URL} class="back-button">‚Üê Back to recipes</a>
      <h1>üõí Shopping List</h1>
    </div>
    <div class="header-actions">
      <button type="button" class="button secondary" id="clearListBtn">
        üóëÔ∏è Clear All
      </button>
    </div>
  </header>

  <div class="shopping-list-container">
    <div id="empty-state" class="empty-state">
      <div class="empty-icon">üõí</div>
      <h2>Your shopping list is empty</h2>
      <p>Add recipes from the recipe pages to build your shopping list!</p>
      <a href={import.meta.env.BASE_URL} class="button primary">
        Browse Recipes
      </a>
    </div>

    <div id="shopping-list-content" class="shopping-list-content" style="display: none;">
      <div class="shopping-list-header">
        <h2>Shopping List</h2>
        <div class="list-stats" id="listStats"></div>
      </div>

      <div class="shopping-list-grid">
        <div class="ingredients-section">
          <h3>Aggregated Ingredients</h3>
          <div id="aggregated-ingredients" class="aggregated-list"></div>
        </div>

        <div class="recipes-section">
          <h3>Recipes</h3>
          <div id="recipes-list" class="recipes-list"></div>
        </div>
      </div>
    </div>
  </div>

  <Fragment slot="scripts">
    <script define:vars={{ baseUrl }} is:inline type="module">
      // Make baseUrl available to the script
      window.BASE_URL = baseUrl;
    </script>
    <script is:inline type="module">
      import { FoodClassifier } from '../../utils/food-classifier.js';
      import { parseQuantityAndUnit, toCanonical, convertToDisplayUnit, formatQuantity } from '../../utils/unit-converter.js';

      class ShoppingListUI {
        constructor() {
          this.classifier = new FoodClassifier();
          this.init();
        }

        // Helper function to normalize ingredient name
        normalizeName(name) {
          return this.classifier.normalizeIngredient(name);
        }

        aggregateIngredients() {
          const aggregated = {};

          window.shoppingList.list.recipes.forEach(recipe => {
            recipe.ingredients.forEach(ingredient => {
              if (!ingredient.name) return;

              const normalizedName = this.normalizeName(ingredient.name);
              const { qty, unit } = parseQuantityAndUnit(ingredient);

              let key, dimension, canonicalQty;

              if (qty !== null && unit !== null) {
                const canonical = toCanonical(qty, unit);
                if (canonical) {
                  // Convertible unit
                  dimension = canonical.dimension;
                  canonicalQty = canonical.canonicalQty;
                  key = `${normalizedName}__${dimension}`;
                } else {
                  // Unknown unit - treat as none
                  dimension = 'none';
                  canonicalQty = null;
                  key = `${normalizedName}__none`;
                }
              } else {
                // No quantity or unit - treat as none
                dimension = 'none';
                canonicalQty = null;
                key = `${normalizedName}__none`;
              }

              if (!aggregated[key]) {
                aggregated[key] = {
                  name: ingredient.name,
                  normalizedName: normalizedName,
                  dimension: dimension,
                  canonicalQty: 0,
                  originalUnit: unit || '',
                  hasQuantity: qty !== null && unit !== null
                };
              }

              // Only sum if we have a convertible quantity
              if (canonicalQty !== null) {
                aggregated[key].canonicalQty += canonicalQty;
                aggregated[key].hasQuantity = true;
              }
            });
          });

          // Convert canonical quantities back to display units
          return Object.values(aggregated).map(item => {
            if (item.hasQuantity && item.dimension !== 'none') {
              const display = convertToDisplayUnit(item.canonicalQty, item.dimension);
              return {
                name: item.name,
                unit: display.unit,
                baseQuantity: display.qty
              };
            } else {
              return {
                name: item.name,
                unit: item.originalUnit || '',
                baseQuantity: item.hasQuantity ? item.canonicalQty : null
              };
            }
          });
        }

        render() {
          const emptyState = document.getElementById('empty-state');
          const content = document.getElementById('shopping-list-content');
          const recipesList = document.getElementById('recipes-list');
          const aggregatedIngredients = document.getElementById('aggregated-ingredients');
          const listStats = document.getElementById('listStats');

          if (!window.shoppingList || !window.shoppingList.list.recipes.length) {
            emptyState.style.display = 'block';
            content.style.display = 'none';
            return;
          }

          emptyState.style.display = 'none';
          content.style.display = 'block';

          // Update stats
          const totalIngredients = window.shoppingList.list.recipes.reduce((sum, recipe) =>
            sum + (recipe.ingredients ? recipe.ingredients.length : 0), 0);
          listStats.textContent = `${window.shoppingList.list.recipes.length} recipe${window.shoppingList.list.recipes.length !== 1 ? 's' : ''}, ${totalIngredients} ingredient${totalIngredients !== 1 ? 's' : ''}`;

          // Render recipes list
          recipesList.innerHTML = '';
          window.shoppingList.list.recipes.forEach(recipe => {
            const recipeItem = document.createElement('div');
            recipeItem.className = 'recipe-item';
            recipeItem.innerHTML = `
              <span class="recipe-title">${recipe.title}</span>
              <button type="button" class="remove-recipe" data-slug="${recipe.slug}" title="Remove recipe">√ó</button>
            `;
            recipesList.appendChild(recipeItem);
          });

          // Render aggregated ingredients with checkboxes, grouped by category
          const aggregated = this.aggregateIngredients();
          aggregatedIngredients.innerHTML = '';

          if (aggregated.length === 0) {
            aggregatedIngredients.innerHTML = '<p class="no-ingredients">No ingredients to show</p>';
          } else {
            // Sort by name first
            aggregated.sort((a, b) => a.name.localeCompare(b.name));

            // Group by category
            const grouped = this.classifier.groupIngredientsByCategory(aggregated);
            let ingredientIndex = 0;

            // Render each category
            Object.keys(grouped).forEach(category => {
              const categorySection = document.createElement('div');
              categorySection.className = 'category-section';

              const categoryHeader = document.createElement('h4');
              categoryHeader.className = 'category-header';
              categoryHeader.textContent = category;
              categorySection.appendChild(categoryHeader);

              const categoryList = document.createElement('div');
              categoryList.className = 'category-ingredients';

              grouped[category].forEach(ingredient => {
                const ingredientDiv = document.createElement('div');
                ingredientDiv.className = 'aggregated-item';

                const quantityText = ingredient.baseQuantity > 0
                  ? `${formatQuantity(ingredient.baseQuantity)}${ingredient.unit ? ' ' + ingredient.unit : ''} `
                  : '';

                ingredientDiv.innerHTML = `
                  <div class="ingredient-main">
                    <input type="checkbox" id="ingredient-${ingredientIndex}" class="ingredient-checkbox">
                    <label for="ingredient-${ingredientIndex}" class="ingredient-label">
                      <span class="ingredient-quantity">${quantityText}</span>
                      <span class="ingredient-name">${ingredient.name}</span>
                    </label>
                  </div>
                `;
                categoryList.appendChild(ingredientDiv);
                ingredientIndex++;
              });

              categorySection.appendChild(categoryList);
              aggregatedIngredients.appendChild(categorySection);
            });
          }
        }

        init() {
          // Wait a bit for global shopping list to be ready and classification data to load
          setTimeout(async () => {
            // Wait for classification data to load
            if (this.classifier.classificationData === null) {
              await new Promise(resolve => {
                const checkData = () => {
                  if (this.classifier.classificationData !== null) {
                    resolve();
                  } else {
                    setTimeout(checkData, 50);
                  }
                };
                checkData();
              });
            }

            this.render();

            // Attach event listeners
            document.getElementById('clearListBtn').addEventListener('click', () => {
              if (window.shoppingList.list.recipes.length > 0 && confirm('Are you sure you want to clear your entire shopping list?')) {
                window.shoppingList.clearAll();
                this.render();
              }
            });

            // Handle recipe removal
            document.getElementById('recipes-list').addEventListener('click', (e) => {
              if (e.target.matches('.remove-recipe')) {
                const slug = e.target.getAttribute('data-slug');
                window.shoppingList.removeRecipe(slug);
                this.render();
              }
            });

            // Handle ingredient checkboxes
            document.getElementById('aggregated-ingredients').addEventListener('change', (e) => {
              if (e.target.matches('.ingredient-checkbox')) {
                const label = e.target.nextElementSibling;
                if (label) {
                  label.classList.toggle('checked', e.target.checked);
                }
              }
            });

          }, 100);
        }
      }

      // Initialize shopping list UI only on this page
      if (document.querySelector('.shopping-list-container')) {
        const shoppingListUI = new ShoppingListUI();
      }
    </script>
  </Fragment>
</Layout>

<style>
  .page-header {
    margin-bottom: 2rem;
  }

  .header-top {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .header-actions {
    display: flex;
    justify-content: flex-end;
  }

  .shopping-list-container {
    max-width: 1000px;
    margin: 0 auto;
  }

  .empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--muted);
  }

  .empty-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.6;
  }

  .empty-state h2 {
    margin-bottom: 1rem;
    color: var(--text);
  }

  .empty-state p {
    margin-bottom: 2rem;
    font-size: 1.1rem;
  }

  .shopping-list-content {
    display: block;
  }

  .shopping-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border);
  }

  .list-stats {
    color: var(--muted);
    font-size: 0.9rem;
  }

  .shopping-list-grid {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 2rem;
  }

  @media (max-width: 968px) {
    .shopping-list-grid {
      grid-template-columns: 1fr;
    }
  }

  .ingredients-section {
    background: var(--surface);
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .ingredients-section h3 {
    color: var(--text);
    margin-top: 0;
    margin-bottom: 1.5rem;
    font-size: 1.3rem;
    border-bottom: 2px solid var(--accent);
    padding-bottom: 0.5rem;
  }

  .recipes-section {
    background: var(--surface);
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .recipes-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .recipe-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--surface);
    padding: 0.75rem 1rem;
    border-radius: 6px;
    border: 1px solid var(--border);
  }

  .recipe-title {
    color: var(--text);
    font-weight: 600;
    flex: 1;
  }

  .recipe-item .remove-recipe {
    background: none;
    border: none;
    color: var(--accent);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 0.25rem;
    border-radius: 4px;
    transition: background-color 0.2s;
    margin-left: 1rem;
  }

  .recipe-item .remove-recipe:hover {
    background-color: var(--border);
  }

  .aggregated-list {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .category-section {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .category-header {
    color: var(--text);
    margin: 0;
    padding: 0.5rem 0;
    font-size: 1.1rem;
    font-weight: 600;
    border-bottom: 1px solid var(--border);
  }

  .category-ingredients {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding-left: 0.5rem;
  }

  .aggregated-item {
    background: var(--surface);
    padding: 1rem;
    border-radius: 6px;
    border: 1px solid var(--border);
  }

  .ingredient-main {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .ingredient-checkbox {
    width: 20px;
    height: 20px;
    cursor: pointer;
  }

  .ingredient-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    flex: 1;
    transition: opacity 0.2s;
  }

  .ingredient-label.checked {
    opacity: 0.4;
    text-decoration: line-through;
  }

  .ingredient-quantity {
    font-weight: 600;
    color: var(--text);
    min-width: 80px;
  }

  .ingredient-name {
    color: var(--text);
    font-weight: 500;
  }


  .no-ingredients {
    color: var(--muted);
    font-style: italic;
    padding: 1rem;
    text-align: center;
  }

  .back-button {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: var(--accent-2);
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    text-decoration: none;
    font-weight: bold;
    border: 0;
    cursor: pointer;
    transition: background 0.2s;
  }

  .back-button:hover {
    background: #0770c9;
    text-decoration: none;
  }

  html[data-theme="dark"] .back-button {
    background: #5db2ff;
  }

  html[data-theme="dark"] .back-button:hover {
    background: #7dc3ff;
  }

  .button {
    background: var(--accent-2);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    text-decoration: none;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    transition: background 0.2s;
  }

  .button:hover {
    background: #0770c9;
    text-decoration: none;
  }

  .button.primary {
    background: var(--accent-2);
  }

  .button.secondary {
    background: var(--surface);
    color: var(--text);
    border: 2px solid var(--border);
  }

  .button.secondary:hover {
    background: var(--border);
  }

  html[data-theme="dark"] .button {
    background: #5db2ff;
  }

  html[data-theme="dark"] .button:hover {
    background: #7dc3ff;
  }
</style>